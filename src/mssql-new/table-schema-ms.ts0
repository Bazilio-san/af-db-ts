// noinspection SqlResolve
import { QueryResultRow } from 'pg';
import { logger } from '../logger-error';
import { graceExit } from '../common';
import { schemaTable } from '../utils';
import { IFieldDefMs, ITableSchemaMs, TColumnsSchemaMs, TUniqueConstraintsMs } from '../@types/i-ms-new';
import { queryMs } from '../mssql/query-ms';

// commonSchemaAndTable: <schema>.<table> :  Staff.nnPersones-personGuid
// schemaAndTableMs: "<schema>"."<table>" :  "Staff"."nnPersones-personGuid"

const tableSchemaHash: { [commonSchemaAndTable: string]: ITableSchemaMs } = {};

const getColumnsSchemaMs_ = async (
  connectionId: string,
  commonSchemaAndTable: string,
): Promise<TColumnsSchemaMs> => {
  const [schema, table] = schemaTable.to.common(commonSchemaAndTable).split('.');
  const sqlText = `SELECT TABLE_SCHEMA,
                          TABLE_NAME,

                          COLUMN_NAME,
                          COLUMN_DEFAULT,
                          IS_NULLABLE,
                          DATA_TYPE,
                          CHARACTER_MAXIMUM_LENGTH,
                          CHARACTER_OCTET_LENGTH,

                          NUMERIC_PRECISION,
                          NUMERIC_PRECISION_RADIX,
                          NUMERIC_SCALE,

                          DATETIME_PRECISION,
                          CHARACTER_SET_NAME,
                          COLLATION_NAME
                   FROM INFORMATION_SCHEMA.COLUMNS
                   WHERE table_name = '${table}'
                     AND table_schema = '${schema}';`;

  let res = await queryMs(connectionId, sqlText, true, `getRecordSchemaMs SQL ERROR`);
  const columnsSchema: TColumnsSchemaMs = {};
  (res?.recordset || []).forEach((fieldDef) => {
    const fieldSchema: IFieldDefMs = {
      name: fieldDef.COLUMN_NAME,
      isNullable: /YES/i.test(fieldDef.IS_NULLABLE || ''),
      columnDefault: fieldDef.COLUMN_DEFAULT,
      hasDefault: !!fieldDef.COLUMN_DEFAULT,
      dataType: fieldDef.data_type,
      maxLen: fieldDef.character_maximum_length,
      precision: fieldDef.numeric_precision,
      radix: fieldDef.numeric_precision_radix,
      dtPrecision: fieldDef.datetime_precision,
      udtName: fieldDef.udt_name,
    };
    if (fieldDef.is_generated === 'NEVER') {
      Object.entries(fieldSchema).forEach(([prop, value]) => {
        if (value == null) {
          delete fieldSchema[prop as keyof IFieldDefMs];
        }
      });
      columnsSchema[fieldDef.COLUMN_NAME] = fieldSchema;
    }
  });
  return columnsSchema;
};

/**
 * Возвращает схему полей таблицы БД. Либо в виде объекта, либо в виде массива
 * Если asArray = true, то вернет TRecordSchemaMs, при этом удалит поля, указанные в omitFields
 * Иначе вернет TRecordSchemaAssocMs
 */
export const getRecordSchemaMs = async (
  // ID соединения (borf|cep|hr|global)
  connectionId: string,
  // Субъект в выражении FROM для таблицы, схему которой нужно вернуть
  commonSchemaAndTable: string,
  // Массив имен полей, которые нужно удалить из схемы (не учитывается, если asArray = false)
  options: TGetRecordSchemaOptionsMs = {} as TGetRecordSchemaOptionsMs,
): Promise<TGetRecordSchemaResultMs | undefined> => {
  commonSchemaAndTable = schemaTable.to.common(commonSchemaAndTable);
  const propertyPath = `schemas.${connectionId}.${commonSchemaAndTable}`;
  const schemaTableMs = schemaTable.to.ms(commonSchemaAndTable);

  let result: TGetRecordSchemaResultMs | undefined = cache.get(propertyPath) as TGetRecordSchemaResultMs | undefined;
  if (result) {
    return result;
  }
  const {
    omitFields,
    pickFields,
    fieldTypeCorrection,
    mergeRules: {
      mergeIdentity = [],
      excludeFromInsert = [],
      noUpdateIfNull = false,
      correction: mergeCorrection,
      withClause,
    } = {},
    noReturnMergeResult,
    dateTimeOptions,
  } = options;
  const cPool = await db.getPoolConnectionMs(connectionId, { prefix: 'getRecordSchemaMs' });
  const request = new sql.Request(cPool);
  request.stream = false;
  let res: IResult<any>;
  try {
    res = await request.query(`SELECT TOP(1) *
                               FROM ${schemaTableMs}`);
  } catch (err) {
    echo.error(`getRecordSchemaMs SQL ERROR`);
    echo.error(err);
    throw err;
  }
  const { columns } = res.recordset;
  const readOnlyFields = Object.entries(columns).filter(([, { readOnly: ro }]) => ro).map(([f]) => f);
  const omitFields2 = [...readOnlyFields, ...(Array.isArray(omitFields) ? omitFields : [])];
  let schemaAssoc: Partial<IColumnMetadata> = omit(columns, omitFields2);
  schemaAssoc = Array.isArray(pickFields) ? pick(schemaAssoc, pickFields) : schemaAssoc;
  correctRecordSchemaMs(schemaAssoc as TRecordSchemaAssocMs, fieldTypeCorrection);
  const schema: ISchemaArrayMs = Object.values(schemaAssoc)
    .sort((a, b) => {
      const ai = (a?.index || 0);
      const bi = (b?.index || 0);
      if (ai > bi) return 1;
      if (ai < bi) return -1;
      return 0;
    }) as ISchemaArrayMs;
  schema.dateTimeOptions = dateTimeOptions;

  const fields = schema.map((o) => o?.name).filter(Boolean) as string[];
  const fieldsList = fields.map((fName) => `[${fName}]`)
    .join(', ');

  const onClause = `(${mergeIdentity.map((fName) => (`target.[${fName}] = source.[${fName}]`))
    .join(' AND ')})`;
  const insertFields = fields.filter((fName) => (!excludeFromInsert.includes(fName)));
  const insertSourceList = insertFields.map((fName) => (`source.[${fName}]`))
    .join(', ');
  const insertFieldsList = insertFields.map((fName) => `[${fName}]`)
    .join(', ');
  const updateFields = fields.filter((fName) => (!mergeIdentity.includes(fName)));
  let updateFieldsList: string;
  if (noUpdateIfNull) {
    updateFieldsList = updateFields.map((fName) => (`target.[${fName}] = COALESCE(source.[${fName}], target.[${fName}])`)).join(', ');
  } else {
    updateFieldsList = updateFields.map((fName) => (`target.[${fName}] = source.[${fName}]`)).join(', ');
  }
  const dbConfig = db.getDbConfigMs<IDBConfigMs>(connectionId, false, true) as IDBConfigMs;
  const dbSchemaAndTable = `[${dbConfig.database}].${schemaTableMs}`;

  result = {
    connectionId,
    dbConfig,
    schemaAndTable: commonSchemaAndTable,
    schemaTableMs,
    dbSchemaAndTable,
    columns,
    schemaAssoc,
    schema,
    fields,
    insertFields,
    insertFieldsList,
    withClause,
    updateFields,
    mergeIdentity,
    getMergeSQL (packet: TRecordSet, prepareOptions: IGetMergeSQLOptionsMs = {}): string {
      if (prepareOptions.isPrepareForSQL) {
        prepareDataForSqlMs(packet, { recordSchema: this.schema, ...prepareOptions });
      }
      const values = `(${packet.map((r) => (fields.map((fName) => (r[fName]))
        .join(',')))
        .join(`)\n,(`)})`;
      let mergeSQL = `
MERGE ${schemaTableMs} ${withClause || ''} AS target
USING
(
    SELECT * FROM
    ( VALUES
        ${values}
    )
    AS s (
    ${fieldsList}
    )
)
AS source
ON ${onClause}
WHEN MATCHED THEN
    UPDATE SET
        ${updateFieldsList}
    WHEN NOT MATCHED THEN
        INSERT (
        ${insertFieldsList}
        )
        VALUES (
        ${insertSourceList}
        )`;
      if (!noReturnMergeResult) {
        mergeSQL = `
${'DECLARE'} @t TABLE ( act VARCHAR(20));
DECLARE @total AS INTEGER;
DECLARE @i AS INTEGER;
DECLARE @u AS INTEGER;
${mergeSQL}
OUTPUT $action INTO @t;
SET @total = @@ROWCOUNT;
SELECT @i = COUNT(*) FROM @t WHERE act = 'INSERT';
SELECT @u = COUNT(*) FROM @t WHERE act != 'INSERT';
SELECT @total as total, @i as inserted, @u as updated;
`;
      } else {
        mergeSQL += `;\n`;
      }
      return typeof mergeCorrection === 'function' ? mergeCorrection(mergeSQL) : mergeSQL;
    },

    getInsertSQL (packet: TRecordSet, addOutputInserted = false): string {
      if (!Array.isArray(packet)) {
        packet = [packet];
      }
      const values = `(${packet.map((r) => (insertFields.map((fName) => (r[fName] === undefined ? 'NULL' : r[fName]))
        .join(',')))
        .join(`)\n,(`)})`;
      return `INSERT INTO ${schemaTableMs} (${insertFieldsList}) ${addOutputInserted ? ' OUTPUT inserted.* ' : ''} VALUES ${values}`;
    },

    getUpdateSQL (record: TRecordSet) {
      const recordForSQL = getRecordValuesForSqlMs(record, this.schema);
      const setArray: string[] = [];
      updateFields.forEach((fName) => {
        if (recordForSQL[fName] !== undefined) {
          setArray.push(`[${fName}] = ${recordForSQL[fName]}`);
        }
      });
      const where = `(${mergeIdentity.map((fName) => (`[${fName}] = ${recordForSQL[fName]}`))
        .join(' AND ')})`;
      return `UPDATE ${schemaTableMs}
              SET ${setArray.join(', ')}
              WHERE ${where};`;
    },
  };

  cache.put(propertyPath, result);
  return result;
};


const getPrimaryKey = async (connectionId: string, commonSchemaAndTable: string): Promise<string[]> => {
  const schemaTableMs = schemaTable.to.pg(commonSchemaAndTable);
  const sql = `
      SELECT a.attname as f
      FROM pg_index i
               JOIN pg_attribute a
                    ON a.attrelid = i.indrelid AND a.attnum = ANY (i.indkey)
      WHERE i.indrelid = '${schemaTableMs}'::regclass
    AND i.indisprimary;`;
  const result = await queryMs(connectionId, sql);

  return (result?.rows || []).map(({ f }) => f);
};

const getUniqueConstraints = async (connectionId: string, commonSchemaAndTable: string): Promise<TUniqueConstraintsMs> => {
  const schemaTableMs = schemaTable.to.pg(commonSchemaAndTable);
  const [schema, table] = schemaTable.to.common(commonSchemaAndTable).split('.');
  const sql = `
      SELECT UI.cn as cn, UI.cols as cols, CASE WHEN UC.cn IS NULL THEN 'UX' ELSE 'UC' END AS typ
      FROM (SELECT c.relname as cn, array_to_json(array_agg(a.attname ORDER BY a.attname)) AS cols
            FROM pg_index i
                     JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY (i.indkey)
                     JOIN pg_class AS c ON c.oid = i.indexrelid
            WHERE i.indrelid = '${schemaTableMs}'::regclass
              AND i.indisunique
              AND NOT i.indisprimary
            GROUP BY c.relname) AS UI
               LEFT OUTER JOIN (SELECT ccu.constraint_name AS cn
                                FROM information_schema.table_constraints tc
                                         JOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_name)
                                         JOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema
                                    AND tc.table_name = c.table_name AND ccu.column_name = c.column_name
                                WHERE tc.table_schema = '${schema}'
                                  AND tc.table_name = '${table}'
                                  AND tc.constraint_type = 'UNIQUE'
                                GROUP BY ccu.constraint_name) AS UC ON UC.cn = UI.cn
      ORDER BY CASE WHEN UC.cn IS NULL THEN 2 ELSE 1 END
  `;
  const result = await queryMs(connectionId, sql);
  const uc: TUniqueConstraintsMs = {};
  result?.rows?.forEach(({ cn, cols }) => {
    uc[cn] = cols;
  });
  return uc;
};

const getSerials = async (connectionId: string, commonSchemaAndTable: string): Promise<string[]> => {
  const fqName = schemaTable.to.common(commonSchemaAndTable);
  const sql = `
      WITH fq_objects AS (SELECT c.oid,
                                 n.nspname || '.' || c.relname AS fqname,
                                 c.relkind,
                                 c.relname                     AS relation
                          FROM pg_class c
                                   JOIN pg_namespace n ON n.oid = c.relnamespace),
           sequences AS (SELECT oid, fqname FROM fq_objects WHERE relkind = 'S'),
           tables AS (SELECT oid, fqname FROM fq_objects WHERE relkind = 'r')
      SELECT t.fqname AS tbl, array_to_json(array_agg(a.attname ORDER BY a.attname)) AS cols
      FROM pg_depend d
               JOIN sequences s ON s.oid = d.objid
               JOIN tables t ON t.oid = d.refobjid
               JOIN pg_attribute a ON a.attrelid = d.refobjid and a.attnum = d.refobjsubid
      WHERE d.deptype = 'a'
        AND t.fqname = '${fqName}'
      GROUP BY t.fqname
  `;
  const result = await queryMs(connectionId, sql);
  return result?.rows?.[0]?.cols || [];
};

export const getTableSchemaMs = async (connectionId: string, commonSchemaAndTable: string): Promise<ITableSchemaMs> => {
  let tableSchema = tableSchemaHash[commonSchemaAndTable];
  if (tableSchema) {
    return tableSchema;
  }
  try {
    const columnsSchema = await getColumnsSchemaMs_(connectionId, commonSchemaAndTable);
    const pk = await getPrimaryKey(connectionId, commonSchemaAndTable);
    const uc = await getUniqueConstraints(connectionId, commonSchemaAndTable);
    const serials = await getSerials(connectionId, commonSchemaAndTable);
    const defaults: { [fieldName: string]: string } = {};
    Object.values(columnsSchema).forEach((fieldDef) => {
      const { name: f, columnDefault, hasDefault } = fieldDef;
      if (hasDefault && !serials.includes(f)) {
        defaults[f] = `${columnDefault}`;
      }
    });
    const fieldsList: string[] = Object.keys(columnsSchema);
    const fieldsWoSerials: string[] = fieldsList.filter((fieldName) => !serials.includes(fieldName));

    tableSchema = {
      columnsSchema, pk, uc, defaults, serials, fieldsList, fieldsWoSerials,
    };
    tableSchemaHash[commonSchemaAndTable] = tableSchema;
  } catch (err) {
    logger.error(`Failed to get schema for table ${commonSchemaAndTable}`);
    logger.error(err);
    await graceExit();
  }
  return tableSchema;
};

export const getFieldsAndValuesMs = <U extends QueryResultRow = QueryResultRow> (record: U, columnsSchema: TColumnsSchemaMs):
  {
    fields: string[],
    fieldsList: string,
    values: any[],
    positionsList: string,
    setFields: string,
    upsertFields: string
  } => {
  const recordNormalized: QueryResultRow = {};
  Object.entries(record).forEach(([f, v]) => {
    const { dataType } = columnsSchema[f] || {};
    if (!dataType) {
      return;
    }
    if ((dataType === EDataTypeMs.jsonb || dataType === EDataTypeMs.json) && Array.isArray(v)) {
      recordNormalized[f] = JSON.stringify(v);
    } else {
      recordNormalized[f] = v;
    }
  });
  const fields: string[] = Object.keys(recordNormalized);
  const fieldsList: string = fields.join(', ');
  const values: any[] = Object.values(recordNormalized);
  const positionsList: string = fields.map((__, i) => `$${++i}`).join(', ');
  const setFields: string = fields.map((f, i) => `${f} = $${++i}`).join(', ');
  const upsertFields: string = fields.map((f) => `${f} = EXCLUDED.${f}`).join(',\n');
  return {
    fields, fieldsList, values, positionsList, setFields, upsertFields,
  };
};
